"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.nestjsPrismaAdd = void 0;
const schematics_1 = require("@angular-devkit/schematics");
const tasks_1 = require("@angular-devkit/schematics/tasks");
const dependencies_1 = require("@schematics/angular/utility/dependencies");
const core_1 = require("@angular-devkit/core");
// You don't have to export the function as default. You can also have more than one rule factory
// per file.
function nestjsPrismaAdd(_options) {
    return (_tree, _context) => {
        if (!_options.skipInstall) {
            _context.addTask(new tasks_1.NodePackageInstallTask());
        }
        return schematics_1.chain([
            addDependencies(_options),
            addNpmScripts(_options),
            addPrismaService(_options),
            addDocker(_options),
            prismaInit(_options),
        ]);
    };
}
exports.nestjsPrismaAdd = nestjsPrismaAdd;
function addDependencies(_options) {
    return (tree) => {
        dependencies_1.addPackageJsonDependency(tree, {
            type: dependencies_1.NodeDependencyType.Dev,
            name: '@prisma/cli',
            version: _options.prismaVersion,
        });
        dependencies_1.addPackageJsonDependency(tree, {
            type: dependencies_1.NodeDependencyType.Default,
            name: '@prisma/client',
            version: _options.prismaVersion,
        });
        return tree;
    };
}
function addNpmScripts(_options) {
    return (tree) => {
        const pkgPath = 'package.json';
        const buffer = tree.read(pkgPath);
        if (buffer === null) {
            throw new schematics_1.SchematicsException('Could not find package.json');
        }
        const pkg = JSON.parse(buffer.toString());
        pkg.scripts['prisma:generate'] = 'npx prisma generate';
        pkg.scripts['prisma:generate:watch'] = 'npx prisma generate --watch';
        pkg.scripts['prisma:save'] = 'npx prisma migrate save --experimental';
        pkg.scripts['prisma:studio'] = 'npx prisma studio';
        pkg.scripts['prisma:up'] = 'npx prisma migrate up --experimental';
        tree.overwrite(pkgPath, JSON.stringify(pkg, null, 2));
        return tree;
    };
}
function addPrismaService(_options) {
    return (_tree) => {
        if (_options.addPrismaService) {
            const sourceTemplates = schematics_1.url('./templates/services');
            const sourceParametrizedTemplates = schematics_1.apply(sourceTemplates, [
                schematics_1.template(Object.assign(Object.assign({}, _options), core_1.strings)),
            ]);
            return schematics_1.mergeWith(sourceParametrizedTemplates);
        }
        return _tree;
    };
}
function addDocker(_options) {
    return (_tree) => {
        if (_options.addDocker) {
            const sourceTemplates = schematics_1.url('./templates/docker');
            const sourceParametrizedTemplates = schematics_1.apply(sourceTemplates, [
                schematics_1.template(Object.assign(Object.assign({}, _options), core_1.strings)),
            ]);
            return schematics_1.mergeWith(sourceParametrizedTemplates);
        }
        return _tree;
    };
}
function prismaInit(_options) {
    return (_tree, context) => {
        if (!_options.skipPrismaInit) {
            const packageInstall = context.addTask(new tasks_1.NodePackageInstallTask());
            context.addTask(new tasks_1.RunSchematicTask('prisma-init', {}), [
                packageInstall,
            ]);
        }
        return _tree;
    };
}
//# sourceMappingURL=index.js.map